---
title: ROS 2 Architecture
sidebar_position: 2
description: Understanding the fundamental architecture and design principles of ROS 2
---

# 3.1 ROS 2 Architecture

The Robot Operating System 2 (ROS 2) represents a fundamental redesign of the original ROS framework to address the challenges of modern robotics applications. With a focus on real-time performance, security, and scalability, ROS 2 introduces a new architecture built on top of industry-standard middleware that enables robust and distributed robotic systems.

## Core Definition

ROS 2 architecture is a distributed computing framework designed for robotic applications that provides communication mechanisms, development tools, and runtime management for complex robotic systems. Unlike its predecessor, ROS 2 is built on a standards-based middleware layer (Data Distribution Service - DDS) that ensures real-time performance, fault tolerance, and secure communication between robotic components.

## Architecture Overview

### Middleware Layer
ROS 2 utilizes DDS (Data Distribution Service) as its underlying communication middleware:

- **Standards-based**: Built on the OMG DDS specification
- **Vendor-neutral**: Supports multiple DDS implementations (Fast DDS, Cyclone DDS, RTI Connext DDS)
- **Real-time capable**: Designed for deterministic communication
- **Scalable**: Supports both local and distributed systems

### Node-Based Architecture
The fundamental organizational unit in ROS 2:

- **Nodes**: Independent processes that perform specific functions
- **Communication**: Nodes communicate via topics, services, and actions
- **Decentralized**: No central master node required
- **Resilient**: Failure of one node doesn't affect others

### Client Library Layer
Language-specific interfaces to the middleware:

- **rclcpp**: C++ client library
- **rclpy**: Python client library
- **rcl**: Generic client library layer
- **Language support**: Multiple language bindings available

## Communication Patterns

### Topics and Publishers/Subscribers
Asynchronous message passing for continuous data streams:

- **Publishers**: Send messages to named topics
- **Subscribers**: Receive messages from named topics
- **Decoupled**: Publishers and subscribers don't need to know about each other
- **QoS Policies**: Quality of Service settings for different communication requirements

### Services and Clients
Synchronous request/response communication:

- **Services**: Provide request/response functionality
- **Clients**: Send requests and wait for responses
- **Synchronous**: Blocking communication pattern
- **Reliable**: Ensures request/response delivery

### Actions
Asynchronous request/response with feedback:

- **Goal**: Long-running tasks with progress feedback
- **Feedback**: Continuous updates during execution
- **Result**: Final outcome of the action
- **Cancel**: Ability to cancel running actions

## Quality of Service (QoS) Policies

### Reliability Policy
Controls message delivery guarantees:

- **Reliable**: All messages delivered (with retries)
- **Best Effort**: Messages delivered without guarantee
- **Use case**: Reliable for critical data, best effort for sensor streams

### Durability Policy
Determines how messages are handled for late-joining subscribers:

- **Transient Local**: Messages stored for late joiners
- **Volatile**: No message storage for late joiners
- **Use case**: Transient for configuration data, volatile for sensor data

### History Policy
Controls how many messages are stored:

- **Keep Last**: Store N most recent messages
- **Keep All**: Store all messages (with memory limitations)
- **Use case**: Keep last for real-time data, keep all for logs

### Deadline and Lifespan
Time-based message handling:

- **Deadline**: Expected response time for messages
- **Lifespan**: Maximum lifetime of messages
- **Use case**: Critical for real-time robotic applications

## Execution Model

### Single Threaded Executor
Simple execution model where callbacks are processed sequentially:

- **Sequential**: One callback at a time
- **Simple**: Easy to reason about
- **Limitation**: Blocking callback affects other callbacks

### Multi-Threaded Executor
Concurrent execution model for better performance:

- **Concurrent**: Multiple callbacks processed simultaneously
- **Performance**: Better utilization of multi-core systems
- **Complexity**: Requires thread-safe code

### Callback Groups
Mechanism to control callback execution:

- **Mutually Exclusive**: Callbacks in same group don't execute simultaneously
- **Reentrant**: Callbacks in same group can execute simultaneously
- **Organization**: Logical grouping of related callbacks

## Namespaces and Naming

### Node Namespaces
Logical grouping of nodes and topics:

- **Hierarchical**: Organize nodes in a tree structure
- **Isolation**: Prevent naming conflicts
- **Scoping**: Control visibility of topics and services

### Remapping
Runtime reconfiguration of names:

- **Flexibility**: Change names without recompilation
- **Deployment**: Adapt to different deployment scenarios
- **Testing**: Use different configurations for testing

## Security Architecture

### Authentication
Verifying node identity:

- **Identity**: Ensuring nodes are who they claim to be
- **Certificates**: Using PKI for authentication
- **Access**: Controlling which nodes can join

### Encryption
Protecting data in transit:

- **Transport**: Encrypting DDS communication
- **Confidentiality**: Protecting sensitive data
- **Integrity**: Ensuring data hasn't been tampered with

### Authorization
Controlling access to resources:

- **Permissions**: Defining what nodes can access
- **Policies**: Configurable access control rules
- **Enforcement**: Implementing access control at middleware level

## Lifecycle Management

### Node Lifecycle States
Structured node state management:

- **Unconfigured**: Node created but not configured
- **Inactive**: Configured but not active
- **Active**: Running and processing data
- **Finalized**: Node cleaned up and ready to be destroyed

### State Transitions
Controlled transitions between states:

- **Configurable**: Moving from unconfigured to inactive
- **Activatable**: Moving from inactive to active
- **Deactivatable**: Moving from active to inactive
- **Cleanable**: Moving to finalized state

## Real-Time Considerations

### Deterministic Communication
Predictable timing for real-time systems:

- **DDS QoS**: Configurable timing guarantees
- **Transport**: Low-latency communication options
- **Scheduling**: Integration with real-time scheduling

### Memory Management
Avoiding dynamic allocation in critical paths:

- **Pre-allocation**: Allocate memory upfront
- **Zero-copy**: Avoid unnecessary memory copies
- **Pool allocators**: Efficient memory management

## Integration with Hardware

### Device Drivers
Connecting hardware to ROS 2:

- **Node-based**: Hardware interfaces as ROS 2 nodes
- **Real-time**: Direct hardware access when needed
- **Abstraction**: Common interfaces for different hardware

### Real-Time Systems
Integration with real-time operating systems:

- **PREEMPT_RT**: Linux real-time patches
- **RT Linux**: Real-time Linux distributions
- **RTOS**: Integration with dedicated RTOS

## Performance Optimization

### Communication Efficiency
Optimizing data transmission:

- **Message size**: Minimizing bandwidth usage
- **Frequency**: Optimizing update rates
- **Compression**: Compressing large data like images

### Resource Management
Efficient use of system resources:

- **CPU**: Multi-threading and scheduling optimization
- **Memory**: Efficient memory usage and allocation
- **Network**: Bandwidth and latency optimization

## Migration from ROS 1

### Key Differences
Major architectural changes from ROS 1:

- **No Master**: Decentralized architecture
- **DDS**: Standards-based middleware
- **Security**: Built-in security features
- **Real-time**: Real-time capable design

### Migration Strategies
Approaches for moving from ROS 1:

- **Bridge**: Tools for ROS 1/ROS 2 interoperability
- **Rewrite**: Complete migration to ROS 2
- **Hybrid**: Mixed ROS 1/ROS 2 systems

**Textual Description of ROS 2 Architecture Diagram**: The diagram would show the layered architecture of ROS 2 with the application layer containing nodes, the client library layer (rclcpp/rclpy), the DDS middleware layer, and the transport layer. It would illustrate the communication patterns with publishers/subscribers, services, and actions, along with QoS policies connecting to each communication type.

## Summary

ROS 2 architecture represents a significant evolution from ROS 1, addressing critical requirements for modern robotic applications including real-time performance, security, and scalability. The DDS-based middleware provides a standards-compliant foundation for distributed robotic systems, while the node-based architecture enables modular and maintainable robot software development.

Understanding the ROS 2 architecture is essential for developing robust robotic applications that can meet the performance and safety requirements of real-world deployments. The various communication patterns, QoS policies, and execution models provide the flexibility needed to build efficient and reliable robotic systems.

## Review Questions

1. Explain the key differences between ROS 1 and ROS 2 architecture.
2. What are Quality of Service (QoS) policies and why are they important in ROS 2?
3. Describe the different communication patterns available in ROS 2.
4. How does ROS 2 handle real-time requirements compared to ROS 1?

## Further Reading

- ROS 2 Design: https://design.ros2.org/
- DDS Specification: https://www.omg.org/spec/DDS/
- ROS 2 Tutorials: https://docs.ros.org/en/rolling/Tutorials.html