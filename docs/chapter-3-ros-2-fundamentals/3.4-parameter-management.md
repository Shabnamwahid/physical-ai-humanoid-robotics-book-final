---
title: Parameter Management
sidebar_position: 5
description: Understanding ROS 2 parameter management for runtime configuration
---

# 3.4 Parameter Management

Parameter management in ROS 2 provides a flexible mechanism for configuring nodes at runtime, enabling dynamic adjustment of robot behavior without recompilation. This system allows developers to modify node behavior, tune algorithms, and adapt to different operating conditions through a unified parameter interface that works across different programming languages and node types.

## Core Definition

Parameter management in ROS 2 refers to the system that allows nodes to declare, access, and modify configuration values at runtime. Parameters are named values (key-value pairs) that control node behavior, such as sensor calibration values, algorithm thresholds, or operational modes. The parameter system provides a standardized way to configure nodes both programmatically and through external tools.

## Parameter Fundamentals

### Parameter Types
ROS 2 supports various data types for parameters:

- **Integer**: 8, 16, 32, and 64-bit signed and unsigned integers
- **Float**: 32 and 64-bit floating point numbers
- **Boolean**: True/false values
- **String**: Text values
- **Array**: Collections of homogeneous values (integer_array, double_array, string_array, bool_array)

### Parameter Declaration
Parameters must be declared before use with optional constraints:

- **Name**: Unique identifier for the parameter
- **Type**: The parameter data type
- **Default value**: Value used if not explicitly set
- **Constraints**: Optional validation rules (min/max values, allowed values)

### Parameter Scope
Parameters can be configured at different levels:

- **Node-level**: Parameters specific to individual nodes
- **Namespace-level**: Parameters affecting groups of nodes
- **Global**: Parameters available to all nodes in the system

## Parameter Architecture

### Parameter Server Implementation
ROS 2 doesn't use a centralized parameter server:

- **Distributed**: Each node maintains its own parameters
- **Discovery-based**: Nodes discover each other's parameters automatically
- **DDS transport**: Parameters communicated via DDS middleware
- **Type safety**: Strong type checking for parameter access

### Parameter Interfaces
Standardized interfaces for parameter access:

- **Node interface**: Built-in parameter functionality in all nodes
- **Client libraries**: Language-specific parameter APIs (rclcpp, rclpy)
- **Command-line tools**: ros2 param command for external access
- **Service-based**: Parameter services for remote access

### Parameter Callbacks
Mechanisms for responding to parameter changes:

- **Set parameter callbacks**: Called when parameters are set
- **Validation**: Validate parameter values before acceptance
- **Transformation**: Transform parameter values during setting
- **Notification**: Notify other components of parameter changes

## Implementation Patterns

### Parameter Declaration in C++
Declaring and using parameters in C++ nodes:

```cpp
#include "rclcpp/rclcpp.hpp"

class ParameterExampleNode : public rclcpp::Node
{
public:
    ParameterExampleNode() : Node("parameter_example")
    {
        // Declare parameters with default values
        this->declare_parameter("robot_name", "default_robot");
        this->declare_parameter("max_velocity", 1.0);
        this->declare_parameter("safety_enabled", true);
        this->declare_parameter("sensor_offsets", std::vector<double>{0.0, 0.0, 0.0});

        // Declare parameter with constraints
        this->declare_parameter("control_frequency", 50,
            rcl_interfaces::msg::ParameterDescriptor()
                .set__description("Control loop frequency in Hz")
                .set__integer_range({rcl_interfaces::msg::IntegerRange()
                    .set__from_value(1)
                    .set__to_value(1000)}));

        // Set parameter callback for validation
        this->set_parameter_callback(
            [this](const std::vector<rclcpp::Parameter> & parameters) {
                auto result = rcl_interfaces::msg::SetParametersResult();
                result.successful = true;

                for (const auto & parameter : parameters) {
                    if (parameter.get_name() == "max_velocity") {
                        if (parameter.as_double() < 0.0) {
                            result.successful = false;
                            result.reason = "Max velocity must be non-negative";
                            break;
                        }
                    }
                }
                return result;
            });
    }
};
```

### Parameter Declaration in Python
Declaring and using parameters in Python nodes:

```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.msg import ParameterDescriptor, IntegerRange

class ParameterExampleNode(Node):
    def __init__(self):
        super().__init__('parameter_example')

        # Declare parameters with default values
        self.declare_parameter('robot_name', 'default_robot')
        self.declare_parameter('max_velocity', 1.0)
        self.declare_parameter('safety_enabled', True)
        self.declare_parameter('sensor_offsets', [0.0, 0.0, 0.0])

        # Declare parameter with descriptor
        desc = ParameterDescriptor()
        desc.description = 'Control loop frequency in Hz'
        desc.integer_range = [IntegerRange(from_value=1, to_value=1000)]
        self.declare_parameter('control_frequency', 50, descriptor=desc)

        # Get parameter values
        robot_name = self.get_parameter('robot_name').value
        max_velocity = self.get_parameter('max_velocity').value
        self.get_logger().info(f'Robot name: {robot_name}, Max velocity: {max_velocity}')
```

### Dynamic Parameter Updates
Handling parameter changes at runtime:

```cpp
// C++ example of parameter change callback
void on_parameter_change()
{
    auto robot_name = this->get_parameter("robot_name").as_string();
    auto max_velocity = this->get_parameter("max_velocity").as_double();

    // Update internal state based on new parameters
    update_robot_configuration(robot_name, max_velocity);

    RCLCPP_INFO(this->get_logger(),
        "Parameters updated: %s, %f", robot_name.c_str(), max_velocity);
}
```

## Parameter Loading and Configuration

### YAML Configuration Files
Loading parameters from YAML files:

```yaml
# config/robot_params.yaml
/**:
  ros__parameters:
    robot_name: "my_robot"
    control_frequency: 100
    safety_enabled: true

my_namespace:
  my_node:
    ros__parameters:
      max_velocity: 2.0
      sensor_offsets: [0.1, 0.2, 0.3]
      thresholds:
        proximity: 0.5
        temperature: 75.0
```

### Launch File Integration
Using parameters in launch files:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    config = os.path.join(
        get_package_share_directory('my_package'),
        'config',
        'robot_params.yaml'
    )

    return LaunchDescription([
        Node(
            package='my_package',
            executable='my_node',
            name='my_node',
            parameters=[config, {'additional_param': 'value'}]
        )
    ])
```

### Command Line Parameter Setting
Setting parameters from the command line:

```bash
# Set a parameter for a specific node
ros2 param set /my_node max_velocity 2.5

# Get parameter value
ros2 param get /my_node robot_name

# List all parameters for a node
ros2 param list /my_node

# Load multiple parameters from a file
ros2 param load /my_node config/params.yaml
```

## Advanced Parameter Features

### Parameter Descriptors
Rich metadata for parameters:

- **Description**: Human-readable parameter descriptions
- **Constraints**: Validation rules (min/max values, allowed values)
- **Read-only**: Parameters that cannot be changed at runtime
- **Dynamic**: Parameters that trigger callbacks when changed

### Parameter Events
Monitoring parameter changes:

- **Parameter events**: Messages published when parameters change
- **Event subscription**: Listen to parameter changes in other nodes
- **History tracking**: Keep history of parameter value changes
- **Logging**: Automatic logging of parameter changes

### Parameter Namespaces
Organizing parameters hierarchically:

- **Node namespaces**: Parameters organized by node names
- **Custom namespaces**: User-defined parameter organization
- **Parameter remapping**: Changing parameter names at runtime
- **Inheritance**: Parameters inherited by child namespaces

## Parameter Best Practices

### Parameter Design Guidelines
Effective parameter design principles:

- **Meaningful names**: Use descriptive, consistent parameter names
- **Appropriate types**: Choose the right parameter type for the data
- **Default values**: Provide sensible default values
- **Documentation**: Document parameters with descriptions

### Parameter Organization
Structuring parameters for maintainability:

- **Grouping**: Group related parameters logically
- **Naming conventions**: Use consistent naming patterns
- **Hierarchical structure**: Use namespaces for organization
- **Validation**: Implement appropriate validation rules

### Performance Considerations
Optimizing parameter usage:

- **Access frequency**: Minimize parameter access in performance-critical code
- **Caching**: Cache parameter values when accessed frequently
- **Batch updates**: Update multiple parameters together when possible
- **Efficient serialization**: Consider serialization overhead for large parameters

## Parameter Security

### Access Control
Controlling parameter access:

- **Permissions**: Restrict who can read/write parameters
- **Authentication**: Verify identity before parameter access
- **Authorization**: Control access based on node credentials
- **Encryption**: Encrypt sensitive parameter values

### Parameter Validation
Ensuring parameter integrity:

- **Type checking**: Validate parameter types before use
- **Range checking**: Validate parameter values are within acceptable ranges
- **Format checking**: Validate string and array formats
- **Dependency checking**: Validate parameter dependencies

## Parameter Migration

### From ROS 1
Differences and migration considerations:

- **No parameter server**: Distributed instead of centralized
- **Type safety**: Stronger type checking in ROS 2
- **API changes**: Updated parameter APIs in client libraries
- **Launch system**: Different approach to parameter loading

### Migration Strategies
Approaches for migrating parameter systems:

- **Parameter mapping**: Map ROS 1 parameters to ROS 2 equivalents
- **Configuration files**: Convert launch files to ROS 2 format
- **API updates**: Update parameter access code
- **Testing**: Verify parameter behavior after migration

## Real-world Applications

### Robot Configuration
Using parameters for robot setup:

- **Calibration**: Sensor and actuator calibration values
- **Physical properties**: Robot dimensions, weights, inertias
- **Operational modes**: Different robot configurations
- **Safety limits**: Velocity, acceleration, and force limits

### Algorithm Tuning
Runtime algorithm adjustment:

- **PID gains**: Proportional, integral, derivative values
- **Filter parameters**: Low-pass filter cutoff frequencies
- **Thresholds**: Detection and classification thresholds
- **Learning rates**: Machine learning algorithm parameters

### Environment Adaptation
Adapting to different operating conditions:

- **Terrain parameters**: Different settings for different surfaces
- **Weather conditions**: Adjustments for environmental factors
- **Task-specific settings**: Different parameters for different tasks
- **User preferences**: Customizable user settings

**Textual Description of Parameter Management Diagram**: The diagram would show a node with various parameters (robot_name, max_velocity, etc.) stored in a parameter server structure. It would illustrate how parameters can be set from different sources (YAML files, command line, other nodes) and how parameter callbacks validate and respond to changes.

## Debugging Parameter Issues

### Common Parameter Problems
Identifying and resolving parameter issues:

- **Parameter not found**: Ensure parameter is declared before use
- **Type mismatch**: Check parameter type matches expected type
- **Scope issues**: Verify parameter name includes correct namespace
- **Default values**: Ensure default values are appropriate

### Diagnostic Tools
Tools for parameter debugging:

- **ros2 param list**: Show all parameters for a node
- **ros2 param get**: Get specific parameter value
- **ros2 param describe**: Show parameter descriptions and constraints
- **rqt_reconfigure**: GUI tool for parameter adjustment

### Logging and Monitoring
Tracking parameter usage:

- **Parameter events**: Monitor parameter changes
- **Logging**: Log parameter access and changes
- **Validation errors**: Monitor for parameter validation failures
- **Performance impact**: Monitor parameter access performance

## Integration with Other Systems

### Configuration Management
Integrating with broader configuration systems:

- **ROS 2 launch**: Parameter loading in launch files
- **External configuration**: Integration with external config systems
- **Database storage**: Storing parameters in databases
- **Version control**: Managing parameter files in version control

### Hardware Integration
Parameters for hardware configuration:

- **Device settings**: Hardware-specific configuration values
- **Calibration data**: Sensor and actuator calibration
- **Firmware parameters**: Settings for embedded systems
- **Communication parameters**: Baud rates, addresses, etc.

## Future Developments

### Parameter Evolution
Potential future enhancements:

- **Parameter groups**: Organize parameters into logical groups
- **Parameter templates**: Reusable parameter configurations
- **Parameter validation**: Enhanced validation capabilities
- **Parameter synchronization**: Better multi-node parameter coordination

## Summary

Parameter management in ROS 2 provides a robust, flexible system for configuring nodes at runtime. The distributed architecture eliminates the single point of failure present in ROS 1 while providing enhanced type safety and validation capabilities. Proper use of parameters enables dynamic robot configuration, algorithm tuning, and environmental adaptation without requiring code changes or recompilation.

The parameter system's integration with launch files, command-line tools, and programmatic interfaces provides multiple ways to configure robotic systems. Following best practices for parameter design and organization ensures maintainable, efficient, and secure robotic applications.

## Review Questions

1. What are the different parameter types supported in ROS 2?
2. How do you declare parameters with validation constraints?
3. Explain the difference between ROS 1 and ROS 2 parameter systems.
4. How can parameters be loaded from YAML configuration files?

## Further Reading

- ROS 2 Parameters: https://docs.ros.org/en/humble/How-To-Guides/Using-Parameters-In-A-Class-CPP.html
- Parameter Descriptors: https://docs.ros.org/en/humble/How-To-Guides/Using-Parameters-In-A-Class-Python.html
- Launch Parameter Loading: https://docs.ros.org/en/humble/How-To-Guides/Launch-system.html