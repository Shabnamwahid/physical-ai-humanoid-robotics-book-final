---
title: Message Passing and Communication
sidebar_position: 4
description: Understanding ROS 2 communication patterns and message passing mechanisms
---

# 3.3 Message Passing and Communication

Communication between different components of a robotic system is fundamental to its operation. ROS 2 provides sophisticated mechanisms for message passing that enable distributed, modular, and robust robotic applications. Understanding these communication patterns is essential for developing effective robotic systems that can coordinate complex behaviors across multiple processes and machines.

## Core Definition

Message passing in ROS 2 refers to the mechanisms that enable nodes to communicate with each other through standardized messages. This includes three primary communication patterns: topics for asynchronous data streaming, services for synchronous request-response interactions, and actions for long-running tasks with feedback. These patterns provide the foundation for distributed robotic applications where components can operate independently while sharing information efficiently.

## Topic-Based Communication

### Publishers and Subscribers
The fundamental asynchronous communication pattern in ROS 2:

- **Publishers**: Nodes that send messages to named topics
- **Subscribers**: Nodes that receive messages from named topics
- **Decoupled**: Publishers and subscribers don't need direct knowledge of each other
- **Broadcast**: One publisher can have multiple subscribers

### Message Types and Definitions
Standardized formats for data exchange:

- **Built-in types**: Basic data types (std_msgs, geometry_msgs, sensor_msgs)
- **Custom types**: User-defined message structures (.msg files)
- **Generation**: Messages automatically generated for different languages
- **Serialization**: Efficient binary serialization of message data

### Topic Architecture
Implementation details of topic communication:

- **DDS-based**: Built on Data Distribution Service middleware
- **Discovery**: Automatic discovery of publishers and subscribers
- **Matching**: Publishers and subscribers match by topic name and type
- **Transport**: Supports various transport protocols (UDP, shared memory)

### Quality of Service (QoS) in Topics
Configurable behavior for different communication requirements:

- **Reliability**: Reliable (guaranteed delivery) or best-effort (no guarantee)
- **Durability**: Transient local (store messages for late joiners) or volatile
- **History**: Keep last N messages or keep all messages
- **Lifespan**: Maximum lifetime of messages in the system

**Textual Description of Topic Communication Diagram**: The diagram would show multiple nodes with publishers sending messages to topics (represented as cloud icons) and subscribers receiving from those topics. It would illustrate how one publisher can have multiple subscribers, and show QoS settings affecting the communication behavior.

## Service-Based Communication

### Request-Response Pattern
Synchronous communication for specific requests:

- **Services**: Provide specific functionality with request/response interface
- **Clients**: Send requests and wait for responses
- **Synchronous**: Blocking communication pattern
- **Reliable**: Guaranteed delivery of requests and responses

### Service Types and Definitions
Standardized service interfaces:

- **Built-in services**: Common robotic services (GetParameters, SetParameters)
- **Custom services**: User-defined service structures (.srv files)
- **Request/Response**: Each service has request and response message types
- **Generation**: Service code automatically generated for different languages

### Service Architecture
Implementation of service communication:

- **Discovery**: Services and clients discover each other automatically
- **Connection**: Direct connection between client and service
- **Blocking**: Client waits for service response
- **Timeout**: Configurable timeout for service calls

### Service QoS Policies
Quality of service settings for service communication:

- **Reliability**: Ensuring request/response delivery
- **Deadline**: Maximum time for service completion
- **Lifespan**: Maximum lifetime of requests
- **Durability**: Storage of service requests for late joiners

## Action-Based Communication

### Long-Running Tasks
Asynchronous communication for tasks with progress feedback:

- **Goal**: Request for a long-running task
- **Feedback**: Continuous updates during task execution
- **Result**: Final outcome of the task
- **Cancel**: Ability to cancel running tasks

### Action Types and Definitions
Structured interface for complex operations:

- **Goal**: Message requesting task execution
- **Feedback**: Message providing progress updates
- **Result**: Message containing final outcome
- **Generation**: Action code automatically generated for different languages

### Action Architecture
Implementation of action communication:

- **Action Server**: Node that executes action goals
- **Action Client**: Node that sends goals and receives feedback/results
- **Non-blocking**: Client can continue while task executes
- **Feedback**: Continuous progress updates during execution

### Action Features
Advanced capabilities of action communication:

- **Preemption**: Canceling and replacing running goals
- **Feedback**: Real-time progress updates
- **Result handling**: Different result types (success, failure, aborted)
- **Goal tracking**: Monitoring goal execution status

## Message Structure and Types

### Standard Message Packages
Commonly used message types in robotics:

- **std_msgs**: Basic data types (Int32, Float64, String, etc.)
- **geometry_msgs**: Geometric data (Pose, Point, Twist, etc.)
- **sensor_msgs**: Sensor data (LaserScan, Image, JointState, etc.)
- **nav_msgs**: Navigation-specific messages (Odometry, Path, etc.)

### Custom Message Definition
Creating application-specific message types:

```bash
# Create message file in pkg_name/msg/MyMessage.msg
string name
int32 id
float64 value
geometry_msgs/Point position
```

### Message Generation Process
Automatic generation of language-specific code:

- **Build system**: Messages compiled during package build
- **Multiple languages**: C++, Python, and other language bindings
- **Serialization**: Automatic serialization/deserialization
- **Validation**: Type checking and validation

## Implementation Patterns

### Publisher Implementation
Creating and using publishers in code:

```cpp
// C++ example
auto publisher = this->create_publisher<std_msgs::msg::String>("topic_name", 10);
auto message = std_msgs::msg::String();
message.data = "Hello World";
publisher->publish(message);
```

```python
# Python example
publisher = self.create_publisher(std_msgs.msg.String, 'topic_name', 10)
msg = std_msgs.msg.String()
msg.data = 'Hello World'
publisher.publish(msg)
```

### Subscriber Implementation
Creating and using subscribers in code:

```cpp
// C++ example
auto subscription = this->create_subscription<std_msgs::msg::String>(
    "topic_name", 10,
    [this](const std_msgs::msg::String::SharedPtr msg) {
        RCLCPP_INFO(this->get_logger(), "Received: '%s'", msg->data.c_str());
    });
```

```python
# Python example
def callback(self, msg):
    self.get_logger().info('Received: "%s"' % msg.data)

subscription = self.create_subscription(
    std_msgs.msg.String, 'topic_name', callback, 10)
```

### Service Implementation
Creating and using services in code:

```cpp
// Service server
auto service = this->create_service<my_pkg::srv::AddTwoInts>(
    "add_two_ints",
    [this](const my_pkg::srv::AddTwoInts::Request::SharedPtr request,
           my_pkg::srv::AddTwoInts::Response::SharedPtr response) {
        response->sum = request->a + request->b;
        RCLCPP_INFO(this->get_logger(), "Incoming request\na: %ld, b: %ld",
                    request->a, request->b);
    });
```

### Action Implementation
Creating and using actions in code:

```cpp
// Action server
auto goal_handle = rclcpp_action::create_server_goal_handle(
    this->get_node_base_interface(),
    this->get_node_clock_interface(),
    this->get_node_logging_interface(),
    this->get_node_waitables_interface(),
    "fibonacci",
    std::bind(&FibonacciActionServer::handle_goal, this, _1, _2),
    std::bind(&FibonacciActionServer::handle_cancel, this, _1),
    std::bind(&FibonacciActionServer::handle_accepted, this, _1));
```

## Performance Considerations

### Message Size Optimization
Efficient communication through optimized message design:

- **Compression**: Compress large data like images or point clouds
- **Sampling**: Reduce frequency of high-bandwidth topics
- **Filtering**: Send only necessary data
- **Aggregation**: Combine multiple small messages

### Bandwidth Management
Managing network resources effectively:

- **Throttling**: Limit message rates for network efficiency
- **Prioritization**: Prioritize critical messages over non-critical
- **Connection management**: Optimize connection establishment
- **Transport selection**: Choose appropriate transport protocols

### Memory Management
Efficient memory usage in message passing:

- **Pre-allocation**: Pre-allocate message objects when possible
- **Zero-copy**: Use zero-copy mechanisms where available
- **Memory pools**: Implement memory pools for frequently allocated objects
- **Garbage collection**: Consider garbage collection impact in Python

## Security Considerations

### Message Integrity
Ensuring messages haven't been tampered with:

- **Authentication**: Verify message origin
- **Encryption**: Encrypt sensitive message content
- **Digital signatures**: Sign messages for integrity verification
- **Checksums**: Use built-in checksums for basic integrity

### Access Control
Controlling who can publish/subscribe to topics:

- **Permissions**: Configure who can access specific topics
- **Authentication**: Verify node identity
- **Authorization**: Control access based on node credentials
- **Encryption**: Encrypt communication channels

## Advanced Communication Patterns

### Publisher-Subscriber Variations
Specialized patterns for specific use cases:

- **Latching**: Publishers that keep the last message for late joiners
- **Transient local**: QoS for configuration data
- **Reliable delivery**: Guaranteed message delivery
- **Best-effort delivery**: High-speed, no-guarantee communication

### Service Variations
Enhanced service patterns:

- **Persistent services**: Long-lived service connections
- **Batch services**: Multiple requests in single call
- **Streaming services**: Continuous data through service interface
- **Asynchronous services**: Non-blocking service calls

### Action Variations
Extended action capabilities:

- **Multi-goal actions**: Execute multiple goals simultaneously
- **Goal preemption**: Cancel and replace running goals
- **Feedback filtering**: Send feedback at specific intervals
- **Result caching**: Store results for later retrieval

## Debugging Communication Issues

### Common Communication Problems
Identifying and resolving communication issues:

- **Topic matching**: Ensure topic names and types match
- **QoS compatibility**: Check QoS settings are compatible
- **Network connectivity**: Verify network connectivity between nodes
- **Node discovery**: Confirm nodes can discover each other

### Diagnostic Tools
Tools for analyzing communication:

- **ros2 topic list**: List available topics
- **ros2 topic echo**: Monitor topic messages
- **ros2 node info**: Show node communication details
- **rqt_graph**: Visualize node connections

### Performance Monitoring
Monitoring communication performance:

- **Message rates**: Monitor publish/subscribe rates
- **Latency measurement**: Measure message delivery time
- **Bandwidth usage**: Track network utilization
- **Memory usage**: Monitor memory consumption

## Integration with Real-time Systems

### Real-time Communication
Ensuring deterministic communication:

- **Deadline QoS**: Set deadlines for time-critical messages
- **Transport priority**: Configure network priority for critical messages
- **Scheduling**: Use real-time scheduling for communication tasks
- **Buffer management**: Pre-allocate communication buffers

### Latency Optimization
Minimizing communication delays:

- **Shared memory**: Use shared memory for local communication
- **Network optimization**: Optimize network stack for low latency
- **Message batching**: Batch small messages to reduce overhead
- **Connection pooling**: Reuse connections for efficiency

## Migration from ROS 1

### Communication Pattern Differences
Key differences between ROS 1 and ROS 2:

- **No Master**: Decentralized discovery instead of central master
- **QoS**: Configurable Quality of Service policies
- **Type checking**: Strict type checking at connection time
- **Security**: Built-in security mechanisms

### Migration Strategies
Approaches for migrating communication patterns:

- **Message definitions**: Same .msg format, different build system
- **API changes**: Updated API for publisher/subscriber creation
- **QoS settings**: Add QoS policies to existing communication
- **Bridge tools**: Use ros1_bridge for mixed systems

## Best Practices

### Design Guidelines
Effective communication design principles:

- **Loose coupling**: Minimize dependencies between nodes
- **Message clarity**: Use clear, descriptive message structures
- **Error handling**: Handle communication failures gracefully
- **Performance**: Consider performance implications of message design

### Naming Conventions
Standardized naming for topics, services, and actions:

- **Lowercase**: Use lowercase names
- **Underscores**: Use underscores for multi-word names
- **Descriptive**: Use descriptive names that indicate purpose
- **Consistency**: Maintain consistency across packages

## Summary

Message passing in ROS 2 provides the essential communication infrastructure for distributed robotic applications. The three primary communication patterns—topics, services, and actions—offer different trade-offs between complexity, reliability, and real-time performance. Understanding these patterns and their appropriate use cases is crucial for developing effective robotic systems.

The QoS system provides powerful configuration options that allow developers to optimize communication for their specific requirements, whether that's guaranteed delivery for critical data or high-speed transmission for sensor streams. Proper design of message structures and communication patterns significantly impacts system performance and maintainability.

## Review Questions

1. Explain the differences between topics, services, and actions in ROS 2.
2. What are Quality of Service (QoS) policies and how do they affect communication?
3. Describe the process of creating custom message types in ROS 2.
4. How does ROS 2 handle communication security compared to ROS 1?

## Further Reading

- ROS 2 Message Passing: https://docs.ros.org/en/humble/Concepts/About-Topics.html
- QoS Implementation: https://docs.ros.org/en/humble/How-To-Guides/Working-with-Qos-Settings.html
- Message Definition: https://docs.ros.org/en/humble/How-To-Guides/Defining-custom-interfaces.html